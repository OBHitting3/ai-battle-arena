/**
 * CASPER ORCHESTRATOR
 *
 * The complete CASPER system that integrates:
 * 1. Niche Validator (85+ score threshold)
 * 2. Multi-AI Persona System (5 AI models)
 * 3. Evaluator Debate System (Paddy, Zuck, Hulk)
 * 4. QR Referral System
 *
 * Complete workflow:
 * - Validate niche profitability
 * - Generate content using multiple AI personas
 * - Evaluate and iterate with expert debate
 * - Track referrals and leaderboards
 */

import { CasperNicheValidator } from './niche-validator';
import { MultiAIPersonaSystem, AIPersona } from './multi-ai-persona';
import { EvaluatorDebateSystem, Evaluator } from './evaluator-debate-system';
import { QRReferralSystem } from './qr-referral-system';
import * as fs from 'fs';
import * as path from 'path';

export interface CasperConfig {
  youtubeApiKey: string;
  anthropicKey: string;
  openaiKey: string;
  geminiKey: string;
  perplexityKey: string;
  grokKey: string;
}

export interface VideoCreationRequest {
  niche: string;
  topic: string;
  duration: number;
  aiPersona?: AIPersona;
  requireConsensus?: boolean;
  maxDebateRounds?: number;
}

export interface VideoCreationResult {
  niche: string;
  topic: string;
  nicheValidation: any;
  aiGeneration: any;
  debateResult: any;
  finalScript: string;
  approved: boolean;
  metadata: {
    persona: AIPersona;
    consensusAchieved: boolean;
    totalDebateRounds: number;
    finalScore: number;
  };
}

export interface TestRun {
  runNumber: number;
  niche: string;
  topic: string;
  persona: AIPersona;
  nicheScore: number;
  nicheApproved: boolean;
  finalDebateScore: number;
  consensusAchieved: boolean;
  debateRounds: number;
  success: boolean;
  timestamp: string;
  duration: number; // milliseconds
}

export class CasperOrchestrator {
  private nicheValidator: CasperNicheValidator;
  private aiPersonaSystem: MultiAIPersonaSystem;
  private debateSystem: EvaluatorDebateSystem;
  private referralSystem: QRReferralSystem;
  private testResults: TestRun[] = [];

  constructor(config: CasperConfig) {
    this.nicheValidator = new CasperNicheValidator(config.youtubeApiKey);

    this.aiPersonaSystem = new MultiAIPersonaSystem({
      anthropicKey: config.anthropicKey,
      openaiKey: config.openaiKey,
      geminiKey: config.geminiKey,
      perplexityKey: config.perplexityKey,
      grokKey: config.grokKey
    });

    this.debateSystem = new EvaluatorDebateSystem(config.anthropicKey);
    this.referralSystem = new QRReferralSystem();
  }

  /**
   * Complete video creation workflow
   */
  async createVideo(request: VideoCreationRequest): Promise<VideoCreationResult> {
    console.log('\n' + '‚ïê'.repeat(100));
    console.log('üëª CASPER - THE FACELESS GHOST');
    console.log('Complete AI-Powered Video Creation System');
    console.log('‚ïê'.repeat(100));

    const startTime = Date.now();

    // STEP 1: Validate niche profitability
    console.log('\nüìä STEP 1: NICHE VALIDATION');
    console.log('‚îÄ'.repeat(100));

    const nicheValidation = await this.nicheValidator.validate(request.niche);

    if (!nicheValidation.approved) {
      console.log('\n‚ùå NICHE REJECTED - Cannot proceed with unprofitable niche');
      console.log(`   Reason: ${nicheValidation.reason}`);
      console.log(`   Score: ${nicheValidation.score}/100 (Minimum: 85)`);

      if (nicheValidation.alternatives.length > 0) {
        console.log('\nüí° Suggested profitable alternatives:');
        nicheValidation.alternatives.forEach((alt, i) => {
          console.log(`   ${i + 1}. "${alt.niche}" (Score: ${alt.score}/100)`);
        });
      }

      throw new Error('Niche validation failed');
    }

    console.log(`\n‚úÖ NICHE APPROVED: "${request.niche}"`);
    console.log(`   Score: ${nicheValidation.score}/100`);
    console.log(`   Est. Monthly Revenue: $${nicheValidation.details.estimatedMonthlyRevenue.toLocaleString()}`);

    // STEP 2: Generate content with AI persona
    console.log('\n\nü§ñ STEP 2: AI CONTENT GENERATION');
    console.log('‚îÄ'.repeat(100));

    const persona = request.aiPersona || AIPersona.CLAUDE;
    const aiGeneration = await this.aiPersonaSystem.generateScript({
      niche: request.niche,
      topic: request.topic,
      duration: request.duration,
      persona
    });

    console.log(`\n‚úÖ Script generated by ${persona}`);
    console.log(`   Word Count: ${aiGeneration.wordCount}`);
    console.log(`   Est. Duration: ${aiGeneration.estimatedDuration.toFixed(1)}s`);
    console.log(`   Thinking Process: ${aiGeneration.thinkingProcess}`);

    // STEP 3: Evaluator debate system
    console.log('\n\nüé≠ STEP 3: EVALUATOR DEBATE');
    console.log('‚îÄ'.repeat(100));

    const debateResult = await this.debateSystem.runDebate(
      aiGeneration.script,
      {
        niche: request.niche,
        topic: request.topic,
        purpose: 'Faceless YouTube video for monetization'
      },
      request.maxDebateRounds || 5
    );

    const approved = request.requireConsensus
      ? debateResult.consensusAchieved
      : debateResult.finalScore >= 85;

    console.log(`\n${approved ? '‚úÖ APPROVED' : '‚ö†Ô∏è  NEEDS IMPROVEMENT'}`);
    console.log(`   Final Score: ${debateResult.finalScore.toFixed(1)}/100`);
    console.log(`   Consensus: ${debateResult.consensusAchieved ? 'YES' : 'NO'}`);
    console.log(`   Debate Rounds: ${debateResult.totalRounds}`);

    const duration = Date.now() - startTime;

    console.log('\n' + '‚ïê'.repeat(100));
    console.log(`üé¨ VIDEO CREATION ${approved ? 'COMPLETE' : 'INCOMPLETE'}`);
    console.log(`   Total Time: ${(duration / 1000).toFixed(1)}s`);
    console.log('‚ïê'.repeat(100) + '\n');

    return {
      niche: request.niche,
      topic: request.topic,
      nicheValidation,
      aiGeneration,
      debateResult,
      finalScript: debateResult.finalContent,
      approved,
      metadata: {
        persona,
        consensusAchieved: debateResult.consensusAchieved,
        totalDebateRounds: debateResult.totalRounds,
        finalScore: debateResult.finalScore
      }
    };
  }

  /**
   * Test CASPER system 100 times with different configurations
   */
  async runComprehensiveTests(iterations: number = 100): Promise<TestRun[]> {
    console.log('\n' + '‚ïê'.repeat(100));
    console.log(`üß™ RUNNING ${iterations} COMPREHENSIVE CASPER TESTS`);
    console.log('‚ïê'.repeat(100) + '\n');

    const testCases = this.generateTestCases(iterations);
    this.testResults = [];

    for (let i = 0; i < testCases.length; i++) {
      const testCase = testCases[i];
      const runNumber = i + 1;

      console.log(`\n${'='.repeat(100)}`);
      console.log(`TEST RUN ${runNumber}/${iterations}`);
      console.log(`${'='.repeat(100)}`);
      console.log(`Niche: ${testCase.niche}`);
      console.log(`Topic: ${testCase.topic}`);
      console.log(`AI Persona: ${testCase.persona}`);
      console.log(`Duration: ${testCase.duration}s\n`);

      const startTime = Date.now();

      try {
        const result = await this.createVideo({
          niche: testCase.niche,
          topic: testCase.topic,
          duration: testCase.duration,
          aiPersona: testCase.persona,
          requireConsensus: false,
          maxDebateRounds: 3 // Limit to 3 rounds for testing
        });

        const testRun: TestRun = {
          runNumber,
          niche: testCase.niche,
          topic: testCase.topic,
          persona: testCase.persona,
          nicheScore: result.nicheValidation.score,
          nicheApproved: result.nicheValidation.approved,
          finalDebateScore: result.metadata.finalScore,
          consensusAchieved: result.metadata.consensusAchieved,
          debateRounds: result.metadata.totalDebateRounds,
          success: result.approved,
          timestamp: new Date().toISOString(),
          duration: Date.now() - startTime
        };

        this.testResults.push(testRun);

        console.log(`\n‚úÖ TEST ${runNumber} PASSED`);
        console.log(`   Niche Score: ${testRun.nicheScore}/100`);
        console.log(`   Debate Score: ${testRun.finalDebateScore.toFixed(1)}/100`);
        console.log(`   Consensus: ${testRun.consensusAchieved ? 'YES' : 'NO'}`);
        console.log(`   Duration: ${(testRun.duration / 1000).toFixed(1)}s`);

      } catch (error: any) {
        console.log(`\n‚ùå TEST ${runNumber} FAILED: ${error.message}`);

        // Still log the failed test
        this.testResults.push({
          runNumber,
          niche: testCase.niche,
          topic: testCase.topic,
          persona: testCase.persona,
          nicheScore: 0,
          nicheApproved: false,
          finalDebateScore: 0,
          consensusAchieved: false,
          debateRounds: 0,
          success: false,
          timestamp: new Date().toISOString(),
          duration: Date.now() - startTime
        });
      }

      // Brief pause between tests
      if (i < testCases.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }

    // Generate comprehensive test report
    this.generateTestReport();

    return this.testResults;
  }

  /**
   * Generate test cases for comprehensive testing
   */
  private generateTestCases(count: number): Array<{
    niche: string;
    topic: string;
    persona: AIPersona;
    duration: number;
  }> {
    const niches = [
      'meditation music',
      'true crime stories',
      'AI automation tutorials',
      'passive income ideas',
      'space documentaries',
      'motivational speeches',
      'reddit stories animated',
      'stock market analysis'
    ];

    const topics = [
      'The Ultimate Guide',
      'Hidden Secrets',
      'Beginner Mistakes',
      'Advanced Strategies',
      'Life-Changing Tips'
    ];

    const personas = Object.values(AIPersona);
    const durations = [30, 60, 90];

    const testCases: Array<{
      niche: string;
      topic: string;
      persona: AIPersona;
      duration: number;
    }> = [];

    for (let i = 0; i < count; i++) {
      const niche = niches[i % niches.length];
      const topicBase = topics[Math.floor(i / niches.length) % topics.length];
      const topic = `${topicBase} for ${niche}`;
      const persona = personas[i % personas.length];
      const duration = durations[i % durations.length];

      testCases.push({ niche, topic, persona, duration });
    }

    return testCases;
  }

  /**
   * Generate comprehensive test report
   */
  private generateTestReport(): void {
    console.log('\n\n' + '‚ïê'.repeat(100));
    console.log('üìä COMPREHENSIVE TEST REPORT');
    console.log('‚ïê'.repeat(100) + '\n');

    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(t => t.success).length;
    const failedTests = totalTests - passedTests;
    const passRate = ((passedTests / totalTests) * 100).toFixed(1);

    console.log('SUMMARY:');
    console.log(`   Total Tests: ${totalTests}`);
    console.log(`   Passed: ${passedTests} (${passRate}%)`);
    console.log(`   Failed: ${failedTests}`);

    const avgNicheScore = this.average(this.testResults.map(t => t.nicheScore));
    const avgDebateScore = this.average(this.testResults.map(t => t.finalDebateScore));
    const avgDuration = this.average(this.testResults.map(t => t.duration));
    const consensusRate = (this.testResults.filter(t => t.consensusAchieved).length / totalTests * 100).toFixed(1);

    console.log('\nAVERAGES:');
    console.log(`   Niche Score: ${avgNicheScore.toFixed(1)}/100`);
    console.log(`   Debate Score: ${avgDebateScore.toFixed(1)}/100`);
    console.log(`   Consensus Rate: ${consensusRate}%`);
    console.log(`   Duration: ${(avgDuration / 1000).toFixed(1)}s per test`);

    // Persona breakdown
    console.log('\nPERFORMANCE BY AI PERSONA:');
    Object.values(AIPersona).forEach(persona => {
      const personaTests = this.testResults.filter(t => t.persona === persona);
      if (personaTests.length > 0) {
        const personaAvgScore = this.average(personaTests.map(t => t.finalDebateScore));
        const personaPassRate = (personaTests.filter(t => t.success).length / personaTests.length * 100).toFixed(1);
        console.log(`   ${persona}: ${personaAvgScore.toFixed(1)}/100 avg | ${personaPassRate}% pass rate`);
      }
    });

    // Save report to file
    const reportPath = path.join(process.cwd(), 'data', 'test-reports', `casper-test-${Date.now()}.json`);
    const reportDir = path.dirname(reportPath);

    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
    }

    fs.writeFileSync(reportPath, JSON.stringify({
      summary: {
        totalTests,
        passedTests,
        failedTests,
        passRate,
        avgNicheScore,
        avgDebateScore,
        avgDuration,
        consensusRate
      },
      testResults: this.testResults
    }, null, 2));

    console.log(`\nüìÑ Full report saved: ${reportPath}`);
    console.log('‚ïê'.repeat(100) + '\n');
  }

  /**
   * Get referral system
   */
  getReferralSystem(): QRReferralSystem {
    return this.referralSystem;
  }

  /**
   * Get test results
   */
  getTestResults(): TestRun[] {
    return this.testResults;
  }

  // Utility
  private average(arr: number[]): number {
    return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  }
}
